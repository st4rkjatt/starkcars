{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.defaultConfig = void 0;\n\nvar _utils = require(\"./utils\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar defaultConfig = {\n  color: '#dee4fd',\n  radius: [0.5, 3.0],\n  speed: [1.0, 3.0],\n  wind: [-0.5, 2.0],\n  changeFrequency: 200\n};\nexports.defaultConfig = defaultConfig;\n/**\r\n * An individual snowflake that will update it's location every call to `update`\r\n * and draw itself to the canvas every call to `draw`.\r\n */\n\nvar Snowflake = /*#__PURE__*/function () {\n  function Snowflake(canvas) {\n    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Snowflake);\n\n    _defineProperty(this, \"config\", void 0);\n\n    _defineProperty(this, \"params\", void 0);\n\n    _defineProperty(this, \"framesSinceLastUpdate\", void 0); // Set custom config\n\n\n    this.updateConfig(config); // Setting initial parameters\n\n    var _this$config = this.config,\n        radius = _this$config.radius,\n        wind = _this$config.wind,\n        speed = _this$config.speed;\n    this.params = {\n      x: (0, _utils.random)(0, canvas.offsetWidth),\n      y: (0, _utils.random)(-canvas.offsetHeight, 0),\n      radius: _utils.random.apply(void 0, _toConsumableArray(radius)),\n      speed: _utils.random.apply(void 0, _toConsumableArray(speed)),\n      wind: _utils.random.apply(void 0, _toConsumableArray(wind)),\n      nextSpeed: _utils.random.apply(void 0, _toConsumableArray(wind)),\n      nextWind: _utils.random.apply(void 0, _toConsumableArray(speed))\n    };\n    this.framesSinceLastUpdate = 0;\n  }\n\n  _createClass(Snowflake, [{\n    key: \"updateConfig\",\n    value: function updateConfig(config) {\n      this.config = _objectSpread(_objectSpread({}, defaultConfig), config);\n    }\n  }, {\n    key: \"updateTargetParams\",\n    value: function updateTargetParams() {\n      this.params.nextSpeed = _utils.random.apply(void 0, _toConsumableArray(this.config.speed));\n      this.params.nextWind = _utils.random.apply(void 0, _toConsumableArray(this.config.wind));\n    }\n  }, {\n    key: \"update\",\n    value: function update(canvas) {\n      var framesPassed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var _this$params = this.params,\n          x = _this$params.x,\n          y = _this$params.y,\n          wind = _this$params.wind,\n          speed = _this$params.speed,\n          nextWind = _this$params.nextWind,\n          nextSpeed = _this$params.nextSpeed; // Update current location, wrapping around if going off the canvas\n\n      this.params.x = (x + wind * framesPassed) % canvas.offsetWidth;\n      this.params.y = (y + speed * framesPassed) % canvas.offsetHeight; // Update the wind and speed towards the desired values\n\n      this.params.speed = (0, _utils.lerp)(speed, nextSpeed, 0.01);\n      this.params.wind = (0, _utils.lerp)(wind, nextWind, 0.01);\n\n      if (this.framesSinceLastUpdate++ > this.config.changeFrequency) {\n        this.updateTargetParams();\n        this.framesSinceLastUpdate = 0;\n      }\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(ctx) {\n      ctx.beginPath();\n      ctx.arc(this.params.x, this.params.y, this.params.radius, 0, 2 * Math.PI);\n      ctx.fillStyle = this.config.color;\n      ctx.closePath();\n      ctx.fill();\n    }\n  }]);\n\n  return Snowflake;\n}();\n\nvar _default = Snowflake;\nexports[\"default\"] = _default;","map":{"version":3,"mappings":"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","names":["defaultConfig","color","radius","speed","wind","changeFrequency","Snowflake","canvas","config","_classCallCheck","_defineProperty","updateConfig","params","x","offsetWidth","y","offsetHeight","random","nextSpeed","nextWind","framesSinceLastUpdate","framesPassed","updateTargetParams","ctx","beginPath","arc","Math","PI","fillStyle","closePath","fill"],"sources":["/home/stark/Videos/cetpa/11/supercar/node_modules/react-snowfall/src/Snowflake.ts"],"sourcesContent":["import { lerp, random } from './utils'\r\n\r\nexport interface SnowflakeProps {\r\n  /** The color of the snowflake, can be any valid CSS color. */\r\n  color: string\r\n  /**\r\n   * The minimum and maximum radius of the snowflake, will be\r\n   * randomly selected within this range.\r\n   *\r\n   * The default value is `[0.5, 3.0]`.\r\n   */\r\n  radius: [number, number]\r\n  /**\r\n   * The minimum and maximum speed of the snowflake.\r\n   *\r\n   * The speed determines how quickly the snowflake moves\r\n   * along the y axis (vertical speed).\r\n   *\r\n   * The values will be randomly selected within this range.\r\n   *\r\n   * The default value is `[1.0, 3.0]`.\r\n   */\r\n  speed: [number, number]\r\n  /**\r\n   * The minimum and maximum wind of the snowflake.\r\n   *\r\n   * The wind determines how quickly the snowflake moves\r\n   * along the x axis (horizontal speed).\r\n   *\r\n   * The values will be randomly selected within this range.\r\n   *\r\n   * The default value is `[-0.5, 2.0]`.\r\n   */\r\n  wind: [number, number]\r\n  /**\r\n   * The frequency in frames that the wind and speed values\r\n   * will update.\r\n   *\r\n   * The default value is 200.\r\n   */\r\n  changeFrequency: number\r\n}\r\n\r\nexport type SnowflakeConfig = Partial<SnowflakeProps>\r\n\r\nexport const defaultConfig: SnowflakeProps = {\r\n  color: '#dee4fd',\r\n  radius: [0.5, 3.0],\r\n  speed: [1.0, 3.0],\r\n  wind: [-0.5, 2.0],\r\n  changeFrequency: 200,\r\n}\r\n\r\ninterface SnowflakeParams {\r\n  x: number\r\n  y: number\r\n  radius: number\r\n  speed: number\r\n  wind: number\r\n  nextSpeed: number\r\n  nextWind: number\r\n}\r\n\r\n/**\r\n * An individual snowflake that will update it's location every call to `update`\r\n * and draw itself to the canvas every call to `draw`.\r\n */\r\nclass Snowflake {\r\n  private config!: SnowflakeProps\r\n  private params: SnowflakeParams\r\n  private framesSinceLastUpdate: number\r\n\r\n  public constructor(canvas: HTMLCanvasElement, config: SnowflakeConfig = {}) {\r\n    // Set custom config\r\n    this.updateConfig(config)\r\n\r\n    // Setting initial parameters\r\n    const { radius, wind, speed } = this.config\r\n\r\n    this.params = {\r\n      x: random(0, canvas.offsetWidth),\r\n      y: random(-canvas.offsetHeight, 0),\r\n      radius: random(...radius),\r\n      speed: random(...speed),\r\n      wind: random(...wind),\r\n      nextSpeed: random(...wind),\r\n      nextWind: random(...speed),\r\n    }\r\n\r\n    this.framesSinceLastUpdate = 0\r\n  }\r\n\r\n  public updateConfig(config: SnowflakeConfig): void {\r\n    this.config = { ...defaultConfig, ...config }\r\n  }\r\n\r\n  private updateTargetParams(): void {\r\n    this.params.nextSpeed = random(...this.config.speed)\r\n    this.params.nextWind = random(...this.config.wind)\r\n  }\r\n\r\n  public update(canvas: HTMLCanvasElement, framesPassed = 1): void {\r\n    const { x, y, wind, speed, nextWind, nextSpeed } = this.params\r\n\r\n    // Update current location, wrapping around if going off the canvas\r\n    this.params.x = (x + wind * framesPassed) % canvas.offsetWidth\r\n    this.params.y = (y + speed * framesPassed) % canvas.offsetHeight\r\n\r\n    // Update the wind and speed towards the desired values\r\n    this.params.speed = lerp(speed, nextSpeed, 0.01)\r\n    this.params.wind = lerp(wind, nextWind, 0.01)\r\n\r\n    if (this.framesSinceLastUpdate++ > this.config.changeFrequency) {\r\n      this.updateTargetParams()\r\n      this.framesSinceLastUpdate = 0\r\n    }\r\n  }\r\n\r\n  public draw(ctx: CanvasRenderingContext2D): void {\r\n    ctx.beginPath()\r\n    ctx.arc(this.params.x, this.params.y, this.params.radius, 0, 2 * Math.PI)\r\n    ctx.fillStyle = this.config.color\r\n    ctx.closePath()\r\n    ctx.fill()\r\n  }\r\n}\r\n\r\nexport default Snowflake\r\n"]},"metadata":{},"sourceType":"script"}